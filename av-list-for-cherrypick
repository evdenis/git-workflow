#!/usr/bin/env perl

use warnings;
use strict;

use feature qw/say/;

use Git::Repository;
use List::Util qw/any/;
use Hash::Ordered;
use Data::Printer;
use List::Util qw/first/;
use YAML::XS qw/LoadFile DumpFile/;

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}

use lib::abs 'lib';
use Git::WorkFlow::AstraVer::Branch qw/list_branches_sorted check_branch_empty/;


my $print = 0;
my $save = 1;

if ((!@ARGV) || (($ARGV[0] ne 'spec') && ($ARGV[0] ne 'devel'))) {
   die "$0 <devel|spec>\n"
}

my $branch = $ARGV[0];
my $r = Git::Repository->new(work_tree => $ENV{CURRENT_PROJECT});
my ($lbranch, $nbranch);
my @branches = list_branches_sorted($r, $branch . '-*');
die "Can't find versioned branches $branch\n"
   unless @branches;

if (check_branch_empty($r, $branch eq 'devel' ? 'master' : $branches[-1] =~ s/^spec/devel/r, $branches[-1])) { # if latest empty, then -2
   if ($branches[-2]) {
      $lbranch = $branches[-2]
   }
   $nbranch = $branches[-1];
} else { # use -1 and create new branch
   $lbranch = $branches[-1];
   #$nbranch = $new
}
die "Can't determine previous versioned branch of development.\n"
   unless $lbranch;
die "You should create new versioned branch $branch first!\n"
   unless $nbranch;
### LATEST BRANCH: $lbranch

my $first_merge;
foreach my $i ($r->run('rev-list' => '--merges' => $branch)) {
   my $parents = $r->run(show => '--format=%P' => $i);
   chomp $parents;
   my @branches = split ' ', $r->run(branch => '--contains' => (split ' ', $parents)[-1]);

   if (any {$_ eq $lbranch} @branches) {
      $first_merge = $i
   } elsif ($first_merge) {
      last
   }
}

unless ($first_merge) {
   my @log = $r->run(log => '--format=%H|%s' => $branch);
   foreach(@log) {
      my ($sha, $msg) = split /\|/;
      if ($msg =~ /merge/i) {
         if ($msg =~ /\Q$lbranch\E/i) {
            $first_merge = $sha
         } else {
            last
         }
      }
   }
}

die "Can't find first merge point for branch $lbranch\n"
   unless $first_merge;

### COMMITS FOR CHERRYPICKING
my $ids;
{
   my $fp = $branch eq 'devel' ? 'master' : ($lbranch =~ s/^spec/devel/r);
   $ids = Hash::Ordered->new(
      map {($_, undef)}
         (
            $r->run('rev-list' => '--reverse' => $fp . '..' . $lbranch),
            $r->run('rev-list' => '--reverse' => $first_merge . '..' . $branch)
         )
   );
}

### NOTES PROCESSING
my %notes;
foreach ($r->run('notes')) {
   my @tmp = split ' ';
   $notes{$tmp[1]}{obj} = $tmp[0]
}
foreach (keys %notes) {
   $notes{$_}{content} = $r->run('cat-file' => '-p' => $notes{$_}{obj});
}
foreach (keys %notes) {
   if ($notes{$_}{content} =~ m/[a-fA-F0-9]{7,40}/p) {
      $notes{$_}{attach} = ${^MATCH}
   } else {
      delete $notes{$_}
   }
}

### ORDER DETERMINATION
{
   my @attached;
   my $iter = $ids->iterator();
   while (my ($sha, $value) = $iter->()) {
      foreach (keys %notes) {
         if ($notes{$_}{attach} && $sha =~ /^$notes{$_}{attach}/) {
            delete $notes{$_}{attach};
            my $nvalue = { %{$notes{$_}}, attached => $_ };
            if ($value) {
               push $value, $nvalue
            } else {
               $value = [ $nvalue ]
            }
            $ids->set($sha => $value);
            delete $notes{$_};
            push @attached, $_;
         }
      }
   }

   $iter = $ids->iterator();
   while (my ($sha, $value) = $iter->()) {
      if ($value) {
         if (@$value > 1) {
            # sorting
            my @keys = $ids->keys;
            my %idx = map { my $v = $_; ( $v, first {$v->{attached} eq $keys[$_]} 0..$#keys) } @$value;
            $ids->set($sha => [sort {$idx{$a} <=> $idx{$b}} @$value])
         }
      }
   }

   foreach (@attached) {
      $ids->delete($_) # Existance is guaranted
   }
}

if (%notes) {
   print STDERR "Dangling notes:\n";
   p %notes;
   die "\n";
}

if ($print) {
   my $iter = $ids->iterator;
   while (my ($k, $v) = $iter->()) {
      unless ($v) {
         print "$k\n"
      } else {
         my %elem = ($k, $v);
         p %elem;
      }
   }
   exit 0;
}

if ($save) {
   DumpFile 'save', $ids
}

$r->run(checkout => $nbranch);
my $iter = $ids->iterator;
while (my ($k, $v) = $iter->()) {
   $r->run('cherry-pick' => $k);
   if ($v) {
      foreach(@$v) {
         $r->run('cherry-pick' => $_->{attached})
      }
   }
}

