#!/usr/bin/env perl

use warnings;
use strict;

use feature qw/say/;

use Git::Repository;
use List::Util qw/any/;
use Hash::Ordered;

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}

use lib::abs 'lib';
use Git::WorkFlow::AstraVer::Branch;


if ((!@ARGV) || (($ARGV[0] ne 'spec') && ($ARGV[0] ne 'devel'))) {
   die "$0 <devel|spec>\n"
}

my $branch = $ARGV[0];
my $r = Git::Repository->new(work_tree => $ENV{CURRENT_PROJECT});
my $lbranch = (list_branches_sorted($r, $branch . '-*'))[-2];
# maybe check for commits in -1 branch?
### LATEST BRANCH: $lbranch

my $first_merge;
foreach my $i ($r->run('rev-list' => '--merges' => $branch)) {
   my $parents = $r->run(show => '--format=%P' => $i);
   chomp $parents;
   my @branches = split ' ', $r->run(branch => '--contains' => (split ' ', $parents)[-1]);

   if (any {$_ eq $lbranch} @branches) {
      $first_merge = $i
   } elsif ($first_merge) {
      last
   }
}

unless ($first_merge) {
   my @log = $r->run(log => '--format=%H|%s' => $branch);
   foreach(@log) {
      my ($sha, $msg) = split /\|/;
      if ($msg =~ /merge/i) {
         if ($msg =~ /\Q$lbranch\E/i) {
            $first_merge = $sha
         } else {
            last
         }
      }
   }
}

die "Can't find first merge point for branch $lbranch\n"
   unless $first_merge;

### COMMITS FOR CHERRYPICKING
my $ids = Hash::Ordered->new(
   map {($_, undef)}
      (
         $r->run('rev-list' => '--reverse' => $lbranch),
         $r->run('rev-list' => '--reverse' => $first_merge . '..' . $branch)
      )
);

### NOTES PROCESSING
my %notes;
foreach ($r->run('notes')) {
   my @tmp = split ' ';
   $notes{$tmp[1]}{obj} = $tmp[0]
}
foreach (keys %notes) {
   $notes{$_}{content} = $r->run('cat-file' => '-p' => $notes{$_}{obj});
}
foreach (keys %notes) {
   unless ($notes{$_}{content} =~ m/[a-fA-F0-9]{7,40}/p) {
      delete $notes{$_}
   } else {
      $notes{$_}{attach} = ${^MATCH}
   }
}

### ORDER DETERMINATION
foreach my $sha ($ids->keys) {
   foreach (keys %notes) {
      if ($sha =~ /^$notes{$_}{attach}/) {
         delete $notes{$_}{attach};
         $notes{$_}{attached} = $_;
         $ids->set($sha => \$notes{$_})
      }
   }
}


use Data::Printer;
p $ids;

