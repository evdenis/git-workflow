#!/usr/bin/env perl

use warnings;
use strict;

use feature qw/say/;

use Git::Repository;
use List::Util qw/any/;
use Hash::Ordered;
use Data::Printer;
use List::Util qw/first/;
use YAML::XS qw/LoadFile DumpFile/;

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}

use lib::abs 'lib';
use Git::WorkFlow::AstraVer::Branch qw/list_branches_sorted check_branch_empty/;
use Git::WorkFlow::AstraVer::Notes;


my $print = 0;
my $save = 1;

if ((!@ARGV) || (($ARGV[0] ne 'spec') && ($ARGV[0] ne 'devel'))) {
   die "$0 <devel|spec>\n"
}

my $branch = $ARGV[0];
my $r = Git::Repository->new(work_tree => $ENV{CURRENT_PROJECT});
my ($lbranch, $nbranch);
my @branches = list_branches_sorted($r, $branch . '-*');
die "Can't find versioned branches $branch\n"
   unless @branches;

if (check_branch_empty($r, $branch eq 'devel' ? 'master' : $branches[-1] =~ s/\Aspec/devel/r, $branches[-1])) { # if latest empty, then -2
   if ($branches[-2]) {
      $lbranch = $branches[-2]
   }
   $nbranch = $branches[-1];
} else { # use -1 and create new branch
   $lbranch = $branches[-1];
   #$nbranch = $new
}
die "Can't determine previous versioned branch of development.\n"
   unless $lbranch;
die "You should create new versioned branch $branch first!\n"
   unless $nbranch;
### LATEST BRANCH: $lbranch

my $first_merge;
foreach my $i ($r->run('rev-list' => '--merges' => $branch)) {
   my $parents = $r->run(show => '--format=%P' => $i);
   chomp $parents;
   my @branches = split ' ', $r->run(branch => '--contains' => (split ' ', $parents)[-1]);

   if (any {$_ eq $lbranch} @branches) {
      $first_merge = $i
   } elsif ($first_merge) {
      last
   }
}

unless ($first_merge) {
   my @log = $r->run(log => '--format=%H|%s' => $branch);
   foreach(@log) {
      my ($sha, $msg) = split /\|/;
      if ($msg =~ /merge/i) {
         if ($msg =~ /\Q$lbranch\E/i) {
            $first_merge = $sha
         } else {
            last
         }
      }
   }
}

die "Can't find first merge point for branch $lbranch\n"
   unless $first_merge;

### COMMITS FOR CHERRYPICKING
my $ids;
{
   my $fp = $branch eq 'devel' ? 'master' : ($lbranch =~ s/^spec/devel/r);
   $ids = Hash::Ordered->new(
      map {($_, undef)}
         (
            $r->run('rev-list' => '--reverse' => $fp . '..' . $lbranch),
            $r->run('rev-list' => '--reverse' => $first_merge . '..' . $branch)
         )
   );
}

### NOTES PROCESSING
my $notes = Git::WorkFlow::AstraVer::Notes->new($r);

### ORDER DETERMINATION
{
   my @attached;
   my $iter = $ids->iterator();
   while (my ($sha, $value) = $iter->()) {
      my $iter = $notes->iterator;
      while (my $nsha = $iter->()) {
         my $note = $notes->get($nsha);
         if ($note->{attach} && $sha =~ /\A$note->{attach}/) {
            delete $note->{attach};
            my $nvalue = { %$note, attached => $nsha };
            if ($value) {
               push $value, $nvalue
            } else {
               $value = [ $nvalue ]
            }
            $ids->set($sha => { updates => $value });
            $notes->delete($nsha);
            push @attached, $nsha;
         }
      }
   }

   # updates sorting
   $iter = $ids->iterator();
   while (my ($sha, $value) = $iter->()) {
      if ($value) {
         if (exists $value->{updates} && @{$value->{updates}} > 1) {
            # sorting
            my @keys = $ids->keys;
            my %idx = map { my $v = $_; ( $v, first {$v->{attached} eq $keys[$_]} 0..$#keys) } @{$value->{updates}};
            $ids->set($sha => { updates => [sort {$idx{$a} <=> $idx{$b}} @{$value->{updates}}] })
         }
      }
   }

   # delete only after updates sorting
   foreach (@attached) {
      $ids->delete($_) # Existance is guaranted
   }
}
{
   # attach regular notes
   my $n_iter = $notes->iterator;
   while (my $sha = $n_iter->()) {
      my $val = $ids->get($sha);
      if ($val) {
         $val->{note} = $notes->get($sha)
      } else {
         $ids->set($sha => {note => $notes->get($sha)})
      }
      $notes->delete($sha);
   }
}

unless ($notes->empty) {
   print STDERR "Dangling notes:\n";
   p $notes;
   die "\n";
}


if ($print) {
   my $iter = $ids->iterator;
   while (my ($k, $v) = $iter->()) {
      unless ($v) {
         print "$k\n"
      } else {
         my %elem = ($k, $v);
         p %elem;
      }
   }
   exit 0;
}

if ($save) {
   DumpFile 'save', $ids
}

$r->run(checkout => $nbranch);
my $iter = $ids->iterator;
while (my ($k, $v) = $iter->()) {
   if ($v) {
      $r->run('cherry-pick' => '--no-commit' => $k);
      foreach(@$v) {
         $r->run('cherry-pick' => '--no-commit' => $_->{attached})
      }
   } else {
      $r->run('cherry-pick' => $k);
   }
}

