#!/usr/bin/env perl

use warnings;
use strict;

use feature qw/say/;

use Git::Repository;
use List::Util qw/any/;
use Hash::Ordered;
use Data::Printer;
use List::Util qw/first/;
use YAML::XS qw/LoadFile DumpFile/;
use Try::Tiny;

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}

use lib::abs 'lib';
use Git::WorkFlow::AstraVer::Branch qw/list_branches_sorted check_branch_empty/;
use Git::WorkFlow::AstraVer::Notes;
use Git::WorkFlow::AstraVer::Commit qw/commit_info/;
use Git::WorkFlow::AstraVer::Repo qw/check_changes_exist/;

$| = 1; #autoflush

my $print = 0;
my $save = 1;

if ((!@ARGV) || (($ARGV[0] ne 'spec') && ($ARGV[0] ne 'devel'))) {
   die "$0 <devel|spec>\n"
}

sub stop
{
   if ($_[0]) {
      say "Stopping for $_[0] at" . (caller)[2]
   } else {
      say "Stop at " . (caller)[2]
   }
   kill 'STOP', $$
}

my $branch = $ARGV[0];
my $r = Git::Repository->new(work_tree => $ENV{CURRENT_PROJECT});
if (check_changes_exist($r)) {
   die "There are changes in repository. You should commit/remove them first.\n";
}

my ($lbranch, $nbranch);
my @branches = list_branches_sorted($r, $branch . '-*');
die "Can't find versioned branches $branch\n"
   unless @branches;

if (check_branch_empty($r, $branch eq 'devel' ? 'master' : $branches[-1] =~ s/\Aspec/devel/r, $branches[-1])) { # if latest empty, then -2
   if ($branches[-2]) {
      $lbranch = $branches[-2]
   }
   $nbranch = $branches[-1];
} else { # use -1 and create new branch
   $lbranch = $branches[-1];
   #$nbranch = $new
}
die "Can't determine previous versioned branch of development.\n"
   unless $lbranch;
die "You should create new versioned branch $branch first!\n"
   unless $nbranch;
### LATEST BRANCH: $lbranch

my $first_merge;
foreach my $i ($r->run('rev-list' => '--merges' => $branch)) {
   my $parents = $r->run(show => '--format=%P' => $i);
   chomp $parents;
   my @branches = split ' ', $r->run(branch => '--contains' => (split ' ', $parents)[-1]);

   if (any {$_ eq $lbranch} @branches) {
      $first_merge = $i
   } elsif ($first_merge) {
      last
   }
}

unless ($first_merge) {
   my @log = $r->run(log => '--format=%H|%s' => $branch);
   foreach(@log) {
      my ($sha, $msg) = split /\|/;
      if ($msg =~ /merge/i) {
         if ($msg =~ /\Q$lbranch\E/i) {
            $first_merge = $sha
         } else {
            last
         }
      }
   }
}

die "Can't find first merge point for branch $lbranch\n"
   unless $first_merge;

### COMMITS FOR CHERRYPICKING
my $ids;
{
   my $fp = $branch eq 'devel' ? 'master' : ($lbranch =~ s/^spec/devel/r);
   $ids = Hash::Ordered->new(
      map {($_, undef)}
         (
            $r->run('rev-list' => '--reverse' => $fp . '..' . $lbranch),
            $r->run('rev-list' => '--reverse' => $first_merge . '..' . $branch)
         )
   );
}

### NOTES PROCESSING
my $notes = Git::WorkFlow::AstraVer::Notes->new($r);

### ORDER DETERMINATION
{
   my @attached;
   my $iter = $ids->iterator();
   while (my ($sha, $value) = $iter->()) {
      my $iter = $notes->iterator;
      while (my $nsha = $iter->()) {
         my $note = $notes->get($nsha);
         if ($note->{attach} && $sha =~ /\A$note->{attach}/) {
            delete $note->{attach};
            my $nvalue = { %$note, attached => $nsha };
            if ($value) {
               push $value, $nvalue
            } else {
               $value = [ $nvalue ]
            }
            $ids->set($sha => { updates => $value });
            $notes->delete($nsha);
            push @attached, $nsha;
         }
      }
   }

   # updates sorting
   $iter = $ids->iterator();
   while (my ($sha, $value) = $iter->()) {
      if ($value) {
         if (exists $value->{updates} && @{$value->{updates}} > 1) {
            # sorting
            my @keys = $ids->keys;
            my %idx = map { my $v = $_; ( $v, first {$v->{attached} eq $keys[$_]} 0..$#keys) } @{$value->{updates}};
            $ids->set($sha => { updates => [sort {$idx{$a} <=> $idx{$b}} @{$value->{updates}}] })
         }
      }
   }

   # delete only after updates sorting
   foreach (@attached) {
      $ids->delete($_) # Existance is guaranted
   }
}
{
   # attach regular notes
   my $n_iter = $notes->iterator;
   while (my $sha = $n_iter->()) {
      my $val = $ids->get($sha);
      if ($val) {
         $val->{note} = $notes->get($sha)
      } else {
         $ids->set($sha => {note => $notes->get($sha)})
      }
      $notes->delete($sha);
   }
}

unless ($notes->empty) {
   print STDERR "Dangling notes:\n";
   p $notes;
   die "\n";
}


if ($print) {
   my $iter = $ids->iterator;
   while (my ($k, $v) = $iter->()) {
      unless ($v) {
         print "$k\n"
      } else {
         my %elem = ($k, $v);
         p %elem;
      }
   }
   exit 0;
}

if ($save) {
   DumpFile 'save', $ids
}

$r->run(checkout => $nbranch);
my $iter = $ids->iterator;
while (my ($k, $v) = $iter->()) {
   if ($v) { ## NOTES, UPDATES
      if (exists $v->{updates}) {
         say '{';
         my $info = commit_info($r, $k);
         my $t = $v->{note}{content} || [[],[]];
         say "\tCP: $info";
         try {
            $r->run('cherry-pick' => $k)
         } catch {
            stop
         };
         foreach(@{$v->{updates}}) {
            my $info = commit_info($r, $_->{attached});
            say "\tCP+: $info";
            try {
               $r->run('cherry-pick' => '--no-commit' => $_->{attached})
            } catch {
               stop
            };
            $t = Git::WorkFlow::AstraVer::Notes::_summarize_tags($t, $_->{tags});
            $r->run('notes' => 'remove' => $_->{attached});
            $r->run('commit' => '-a' => '--amend' => '-F' => '.git/COMMIT_EDITMSG');
         }
         stop; # for message editing

         my $note = Git::WorkFlow::AstraVer::Notes::_tags_to_string($t);
         say "\tNOTE: $note";
         $r->run('notes' => 'add' => '-m' => $note);
         $r->run('notes' => 'remove' => $k);
         say '}';
      } else {
         say '{';
         my $info = commit_info($r, $k);
         say "\tCP: $info";
         try {
            $r->run('cherry-pick' => $k)
         } catch {
            stop
         };
         say "\tNOTE: $v->{note}{content}";
         $r->run('notes' => 'add' => '-C' => $v->{note}{obj});
         $r->run('notes' => 'remove' => $k);
         say '}';
      }
   } else {  ## NO NOTES
      my $info = commit_info($r, $k);
      say "CP: $info";
      try {
         $r->run('cherry-pick' => $k, {fatal => 1})
      } catch {
         stop
      };
   }
}

